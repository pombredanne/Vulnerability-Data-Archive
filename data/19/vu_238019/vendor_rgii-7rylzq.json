{
  "Addendum": "There are no additional comments at this time.",
  "DateLastUpdated": "2009-05-13T10:46:00-04:00",
  "DateNotified": "",
  "DateResponded": "2009-05-12T09:15:44-04:00",
  "ID": "VU#238019",
  "Revision": 3,
  "Status": "Vulnerable",
  "Vendor": "Cyrus-IMAP",
  "VendorInformation": "While this patch will fix currently vulnerable code, it can cause non-vulnerable existing code to break. Here's a function prototype from include/saslutil.h to clarify my explanation: /* base64 encode\n*  in      -- input data\n*  inlen   -- input data length\n*  out     -- output buffer (will be NUL terminated)\n*  outmax  -- max size of output buffer\n* result: *  outlen  -- gets actual length of output buffer (optional) * Returns SASL_OK on success, SASL_BUFOVER if result won't fit LIBSASL_API int sasl_encode64(const char *in, unsigned inlen,\nchar *out, unsigned outmax,\nunsigned *outlen); Assume a scenario where calling code has been written in such a way that it calculates the exact size required for base64 encoding in advance, then allocates a buffer of that exact size, passing a pointer to the\nbuffer into sasl_encode64() as *out. As long as this code does not anticipate that the buffer is NUL-terminated (does not call any string-handling functions like strlen(), for example) the code will work and it will not be vulnerable. Once this patch is applied, that same code will break because sasl_encode64() will begin to return SASL_BUFOVER.",
  "VendorRecordID": "RGII-7RYLZQ",
  "VendorReferences": "",
  "VendorStatement": "No statement is currently available from the vendor regarding this vulnerability."
}