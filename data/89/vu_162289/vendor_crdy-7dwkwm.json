{
  "Addendum": "Vendors and developers using the GNU C compiler should consider using versions of GCC that do not perform the optimization such as those listed above or GCC 4.1.2 or earlier versions (but NOT 4.1.0).",
  "DateLastUpdated": "2008-07-29T15:37:00-04:00",
  "DateNotified": "",
  "DateResponded": "2008-05-12T00:00:00",
  "ID": "VU#162289",
  "Revision": 5,
  "Status": "Vulnerable",
  "Vendor": "GNU Compiler Collection",
  "VendorInformation": "We are not aware of further vendor information regarding this vulnerability.",
  "VendorRecordID": "CRDY-7DWKWM",
  "VendorReferences": "",
  "VendorStatement": "The behaviour of pointer overflow has now changed as of the following\n(as yet unreleased) versions: gcc 4.2.4\ngcc 4.3.1\ngcc 4.4.0 and all subsequent versions (4.2.x where x >= 4, 4.3.y where y >= 1,\n4.z where z >= 4). The optimization under discussion is for comparisons between P + V1\nand P + V2, where P is the same pointer and V1 and V2 are variables of\nsome integer type. The C/C++ language standards permit this to be\nreduced to a comparison between V1 and V2. However, if V1 or V2 are\nsuch that the sum with P overflows, then the comparison of V1 and V2\nwill not yield the same result as actually computing P + V1 and P + V2\nand comparing the sums. The new behaviour as of the above releases is that this optimization\nis performed by default at -O2 and above, including -Os. It is not\nperformed by default at -O1 or (of course) -O0. The optimization may\nbe enabled for -O1 with the -fstrict-overflow option. The\noptimization may be disabled for -O2 and above with the\n-fno-strict-overflow option. When the optimization is enabled, cases where it occurs may be\ndetected by using -Wstrict-overflow=N where N >= 3. Note that using\nthis warning option is likely to yield a number of false positive\nreports--cases where this or other overflow optimizations are being\napplied, but where there is no actual problem. Please see the gcc manual for more information about these options."
}