{
  "Author": "This document was written by new-vul.",
  "CAM_AttackerAccessRequired": "0",
  "CAM_EaseOfExploitation": "0",
  "CAM_Exploitation": "0",
  "CAM_Impact": "0",
  "CAM_InternetInfrastructure": "0",
  "CAM_Population": "0",
  "CAM_ScoreCurrent": 0,
  "CAM_ScoreCurrentWidelyKnown": 0,
  "CAM_ScoreCurrentWidelyKnownExploited": 0,
  "CAM_WidelyKnown": "0",
  "CERTAdvisory": "",
  "CVEIDs": "",
  "CVSS_AccessComplexity": "",
  "CVSS_AccessVector": "",
  "CVSS_Authenication": "",
  "CVSS_AvailabilityImpact": "",
  "CVSS_BaseScore": "",
  "CVSS_BaseVector": "",
  "CVSS_CollateralDamagePotential": "",
  "CVSS_ConfidentialityImpact": "",
  "CVSS_EnvironmentalScore": "",
  "CVSS_EnvironmentalVector": "",
  "CVSS_Exploitability": "",
  "CVSS_IntegrityImpact": "",
  "CVSS_RemediationLevel": "",
  "CVSS_ReportConfidence": "",
  "CVSS_SecurityRequirementsAR": "",
  "CVSS_SecurityRequirementsCR": "",
  "CVSS_SecurityRequirementsIR": "",
  "CVSS_TargetDistribution": "",
  "CVSS_TemporalScore": "",
  "CVSS_TemporalVector": "",
  "DateCreated": "1998-05-21T11:26:11-04:00",
  "DateFirstPublished": "",
  "DateLastUpdated": "1998-05-21T11:25:36+00:00",
  "DatePublic": "",
  "Description": "(placeholder)\n\nSome SPARC chips appear to contain a bug in the operation of the\nreturn from trap instruction.\n\nOn such chips a return from trap instruction does not re-enable\ninterrupts until the two subsequent instructions have been executed.\nBy making either one of these two instructions also trap it is\npossible to write a user program that locks out interrupts for an\narbitrary period of time.\n\nThe affected chips are the Fujitsu MB86901A, and the equivalent chip\nproduced by LSI Logic (L64801?) [1].",
  "ID": "VU#11461",
  "IDNumber": "11461",
  "IPProtocol": "",
  "Impact": "Unless trap handlers are written with this bug in mind a malicious\nuser program is able to perform a denial of service attack. (Note\nthat in an open networking environment a denial of service attack may\nprovide a window of opportunity in which an unsecured host can forge\nthe identity of the host under attack.) In the case of window trap handlers (where the faulting instruction\nwill be re-executed) only a single additional instruction can be\nexecuted with traps disabled. Thus the worst damage that could be\ninflicted exploiting this bug, and making use of window trap handlers\non their own, would be to temporarily freeze the machine while a\nstraight line code sequence was being executed. To give you a rough\nidea of this, 32M of memory filled with save instructions might freeze\na typical machine for one minute. Unfortunately on some machines this\nwould have the side effect of causing a watchdog reset to occur.",
  "Keywords": [
    "traps",
    "denial of service"
  ],
  "Overview": "",
  "References": "none",
  "Resolution": "",
  "Revision": "1",
  "SystemsAffectedPreamble": "",
  "ThanksAndCredit": "",
  "Title": "traps",
  "US-CERTTechnicalAlert": "",
  "VRDA_D1_DirectReport": "",
  "VRDA_D1_Impact": "",
  "VRDA_D1_Population": "",
  "VulnerabilityCount": 1,
  "Workarounds": "Several ways to prevent this bug from being exploited are: - Make sure that traps are enabled at some point within the\nexecution of a trap handler. This may be costly or difficult, for\ninstance if a free register window is not available. - Perform the return from trap to a special trusted page in user\nspace that provides the requisite 2 non-trapping instruction\ncycles and then jumps to the real return address. This requires\nthe operating system consume two registers to contain the real PC\nand nPC. If the SPARC ABI, which allows for up to 4 such\nregisters is not been followed this may not be possible. - Examine the two instructions to be executed upon returning from\nthe trap, and if either of them may likewise trap. Either, abort\nthe program - if such programs are known to never be generated by\nthe various compilers that are used. Or execute special code that\nallows any pending interrupt to occur before returning to the\nuser. One possible way of doing this is to try and pretend that a\npseudo-clock interrupt has occurred, this will give the higher\nlevels of the operating system a chance to perform a rescheduling. - Keep track of where the previous trap returned to, and if the\nfollowing trap occurs at the same address (actually one of two\npossible addresses) make sure the special code is first executed. - Keep count of the number of traps that are occurring, and after\nevery 10000 traps make sure an interrupt is given a chance to\noccur."
}